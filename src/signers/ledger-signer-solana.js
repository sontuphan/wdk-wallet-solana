'use strict'

import { constructOffchainMessageV0Content } from './signer-solana.js'

import {
  DeviceActionStatus,
  DeviceManagementKitBuilder
} from '@ledgerhq/device-management-kit'
import { webHidTransportFactory } from '@ledgerhq/device-transport-kit-web-hid'
import { SignerSolanaBuilder } from '@ledgerhq/device-signer-kit-solana'
import { filter, firstValueFrom, map } from 'rxjs'
import { getBase58Encoder } from '@solana/codecs'
import { getOffchainMessageEnvelopeDecoder } from '@solana/offchain-messages'
import { signatureBytes, verifySignature } from '@solana/keys'
import { address, getPublicKeyFromAddress } from '@solana/addresses'
import { getCompiledTransactionMessageEncoder } from '@solana/transaction-messages'
import {
  getTransactionDecoder,
  getTransactionEncoder
} from '@solana/transactions'

const BIP_44_SOL_DERIVATION_PATH_PREFIX = "m/44'/501'"

/**
 * @typedef {import("./signer-solana.js").ISignerSolana} ISignerSolana
 */

/**
 * @typedef {import("@ledgerhq/device-management-kit").DeviceManagementKit} DeviceManagementKit
 */

/**
 * @typedef {import("@ledgerhq/device-signer-kit-solana/internal/DefaultSignerSolana.js").DefaultSignerSolana} DefaultSignerSolana
 */

/**
 * @typedef {Object} LedgerSignerSolOpts
 * @property {DeviceManagementKit} [dmk] Shared [DMK](https://developers.ledger.com/docs/device-interaction/integration/how_to/dmk).
 */

/**
 * @typedef {Object} LedgerSignerSolCfg
 */

/**
 * @implements {ISignerSolana}
 */
export default class LedgerSignerSol {
  /**
   * @constructor
   * @param {string} path The BIP-44 derivation path (e.g. "0'/0'"). Note that, All child paths must be hardened in Solana.
   * @param {LedgerSignerSolCfg} config
   * @param {LedgerSignerSolOpts} opts
   */
  constructor (path, config = {}, opts = {}) {
    if (!path) {
      throw new Error('Path is required.')
    }

    this._config = config
    /**
     * @type {DefaultSignerSolana | undefined} The solana signer.
     */
    this._account = undefined
    this._address = undefined
    this._sessionId = ''
    this._path = `${BIP_44_SOL_DERIVATION_PATH_PREFIX}/${path}`
    this._isActive = false

    /**
     * @type {DeviceManagementKit}
     */
    this._dmk =
      opts.dmk ||
      new DeviceManagementKitBuilder()
        .addTransport(webHidTransportFactory)
        .build()
  }

  get isActive () {
    return this._isActive
  }

  get index () {
    if (!this._path) return undefined
    return +this._path.replace(/'/g, '').split('/').pop()
  }

  get path () {
    return this._path
  }

  get config () {
    return this._config
  }

  get address () {
    if (!this._account) throw new Error('Ledger is not connected yet.')
    return this._address
  }

  /**
   * Discover and connect the device
   *
   * @private
   */
  async _connect () {
    // Discover & Connect the device
    const device = await firstValueFrom(this._dmk.startDiscovering({}))
    this._sessionId = await this._dmk.connect({
      device,
      sessionRefresherOptions: { isRefresherDisabled: true }
    })

    // Create a hardware signer
    this._account = new SignerSolanaBuilder({
      dmk: this._dmk,
      sessionId: this._sessionId
    }).build()

    // Get the pubkey
    const { observable } = this._account.getAddress(this._path)
    const address = await firstValueFrom(
      observable.pipe(
        filter((evt) => evt.status === DeviceActionStatus.Completed),
        map((evt) => evt.output)
      )
    )

    // Active
    this._address = address
    this._isActive = true
  }

  /**
   * Derive child signer
   * @param {string} relPath The BIP-44 derivation path (e.g. "0'/0'"). Note that, All child paths must be hardened in Solana.
   * @param {LedgerSignerSolCfg} cfg
   * @returns
   */
  derive (relPath, cfg = {}) {
    /**
     * @type {LedgerSignerSolCfg}
     */
    const mergedCfg = {
      ...this._config,
      ...Object.fromEntries(
        Object.entries(cfg).filter(([, v]) => v !== undefined)
      )
    }

    /**
     * @type {LedgerSignerSolOpts}
     */
    const mergedOpts = {
      ...this.opts,
      dmk: this._dmk
    }

    return new LedgerSignerSol(
      `${this._path}/${relPath}`,
      mergedCfg,
      mergedOpts
    )
  }

  async getAddress () {
    if (!this._account) await this._connect()
    return this._address
  }

  async sign (message) {
    if (!this._account) await this._connect()

    const { observable } = this._account.signMessage(this._path, message)
    const { signature: envelopedSignature } = await firstValueFrom(
      observable.pipe(
        filter((evt) => evt.status === DeviceActionStatus.Completed),
        map((evt) => evt.output)
      )
    )

    const { signatures } = getOffchainMessageEnvelopeDecoder().decode(
      getBase58Encoder().encode(envelopedSignature)
    )
    const [signature] = Object.values(signatures)

    return Buffer.from(signature).toString('hex')
  }

  async verify (message, signature) {
    if (!this._address) return false

    const pubkey = await getPublicKeyFromAddress(address(this._address))

    const messageBytes = constructOffchainMessageV0Content(
      this._address,
      message
    )
    const signatureBytes = Buffer.from(signature, 'hex')

    const isValid = await verifySignature(pubkey, signatureBytes, messageBytes)

    return isValid
  }

  async signTransaction (unsignedTx) {
    if (!this._account) await this._connect()

    const tx = getTransactionDecoder().decode(unsignedTx)

    /**
     * @type {TransactionMessageBytes} Cast the type from ReadonlyUint8Array<ArrayBuffer> to TransactionMessageBytes
     */
    const compiledTransactionMessage =
      getCompiledTransactionMessageEncoder().encode(tx)

    const { observable } = this._account.signTransaction(
      this._path,
      Uint8Array.from(compiledTransactionMessage)
    )
    const signature = await firstValueFrom(
      observable.pipe(
        filter((evt) => evt.status === DeviceActionStatus.Completed),
        map((evt) => evt.output)
      )
    )

    const readonlySignedTransaction = getTransactionEncoder().encode({
      messageBytes: compiledTransactionMessage,
      signatures: {
        [address(this._address)]: signatureBytes(signature)
      }
    })

    return Uint8Array.from(readonlySignedTransaction)
  }

  dispose () {
    if (this._account) this._dmk.disconnect({ sessionId: this._sessionId })

    this._account = undefined
    this._dmk = undefined
    this._sessionId = ''
    this._isActive = false
  }
}
